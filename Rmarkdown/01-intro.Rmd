# Introduction

Welcome to the Programmer Knowledge Base. Over the last few years, I've noticed that young data scientists are often very statistically advanced, but are sometimes programmatically beginners. The goal of this book is to introduce some best programming practices to produce high-quality code.

The best practices are first introduced as concept and then are exemplied for several different languages.

## High-quality code

What do we mean by 'high-quality code'?

In my mind, there are two parts to high-quality code. High-quality code a) is reproducible across three dimensions: people, time, and machines and b) efficient

### Reproducibility

* **People**: code should be reproducible across multiple programmers. Programmer B should be able to run Programmer A's output and return the same output.
* **Time**: code should be reproducible across time. Code run today should still be able to be run a year from now and return the same output.    
* **Software/Machines**: Code should not be machine specific! This is an especially important concept for those using open-source software. Open-source software can change extremely quickly, and functions or packages that were used a month ago, may no longer work in the same way or have the same functions today.

There's no one way to maintain reproducible code bases across these three dimensions, but there are several best practices that the broader data science, statistics, and computer science communities seem be in consensus on.

Specificially we'll talk about^[note: these topics are not listed in order of importance, they are all very important!]:

* Configuration files
* Documentation
* Code version control and the software development lifecycle
* Virtual environments and package managers
* Building packages
* Testing
* Data Archiving

### Efficiency

Specifically we'll talk about: 

* Benchmarking
* Profiling
* Parallel processing
* Computing resources (Azure, AWS, etc.)

## What's the point?

There are many reasons that come to mind as to why we want our code to be reproducible across people, time, and machines. The first is purely practical. If you're working for a company or doing your own research, and someone comes to you and says how did you get this result. You obviously, go back tot the code and say oh well here's how. But then you remember you were in a mad scramble to finish the project before the deadline, so things were a little messier than you expected, and oh yes, all of your packages have been updated since then, so some of the functions don't work anymore, and you forgot some important documentation that tells you how to run the program in the first place, and oh which dataset did we end up using for the final_final_final_v3 results, and oh I think my co-worker worked on that part, and which code was it create_df1_final, or create_df2.2, but oh wasn't there a bug in create_df2.2, so many we actuallu used create_df1_final but didn't fix create_df2.2 because we ran out of time because it was a really tight deadline and STOPPPPPP!

I think anyone working in code and especially those on a team has come across at least one, if not many, of these situations before. I noticed myself in all of these situations since I've started programming, and I started to think there has to be a better way to do all of this. And thankfully, there is, which is what will be discussed in this book! 









